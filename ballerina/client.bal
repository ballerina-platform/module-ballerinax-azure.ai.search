// AUTO-GENERATED FILE. DO NOT MODIFY.
// This file is auto-generated by the Ballerina OpenAPI tool.

// Copyright (c) 2025, WSO2 LLC. (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/data.jsondata;
import ballerina/http;

# Client that can be used to manage and query indexes and documents, as well as manage other resources, on a search service.
public isolated client class Client {
    final http:Client clientEp;
    # Gets invoked to initialize the `connector`.
    #
    # + config - The configurations to be used when initializing the `connector` 
    # + serviceUrl - URL of the target service 
    # + return - An error if connector initialization failed 
    public isolated function init(string serviceUrl, ConnectionConfig config =  {}) returns error? {
        http:ClientConfiguration httpClientConfig = {httpVersion: config.httpVersion, http1Settings: config.http1Settings, http2Settings: config.http2Settings, timeout: config.timeout, forwarded: config.forwarded, followRedirects: config.followRedirects, poolConfig: config.poolConfig, cache: config.cache, compression: config.compression, circuitBreaker: config.circuitBreaker, retryConfig: config.retryConfig, cookieConfig: config.cookieConfig, responseLimits: config.responseLimits, secureSocket: config.secureSocket, proxy: config.proxy, socketConfig: config.socketConfig, validation: config.validation, laxDataBinding: config.laxDataBinding};
        self.clientEp = check new (serviceUrl, httpClientConfig);
    }

    # Retrieves a datasource definition.
    #
    # + dataSourceName - The name of the datasource to retrieve.
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    remote isolated function dataSourcesGet(string dataSourceName, DataSourcesGetHeaders headers = {}, *DataSourcesGetQueries queries) returns SearchIndexerDataSource|error {
        string resourcePath = string `/datasources('${getEncodedUri(dataSourceName)}')`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Creates a new datasource or updates a datasource if it already exists.
    #
    # + dataSourceName - The name of the datasource to create or update.
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The definition of the datasource to create or update. 
    remote isolated function dataSourcesCreateOrUpdate(string dataSourceName, DataSourcesCreateOrUpdateHeaders headers, SearchIndexerDataSource payload, *DataSourcesCreateOrUpdateQueries queries) returns SearchIndexerDataSource|error {
        string resourcePath = string `/datasources('${getEncodedUri(dataSourceName)}')`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Deletes a datasource.
    #
    # + dataSourceName - The name of the datasource to delete.
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    remote isolated function dataSourcesDelete(string dataSourceName, DataSourcesDeleteHeaders headers = {}, *DataSourcesDeleteQueries queries) returns error? {
        string resourcePath = string `/datasources('${getEncodedUri(dataSourceName)}')`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Lists all datasources available for a search service.
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    remote isolated function dataSourcesList(DataSourcesListHeaders headers = {}, *DataSourcesListQueries queries) returns ListDataSourcesResult|error {
        string resourcePath = string `/datasources`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Creates a new datasource.
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The definition of the datasource to create. 
    remote isolated function dataSourcesCreate(SearchIndexerDataSource payload, DataSourcesCreateHeaders headers = {}, *DataSourcesCreateQueries queries) returns SearchIndexerDataSource|error {
        string resourcePath = string `/datasources`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Resets the change tracking state associated with an indexer.
    #
    # + indexerName - The name of the indexer to reset.
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    remote isolated function indexersReset(string indexerName, IndexersResetHeaders headers = {}, *IndexersResetQueries queries) returns error? {
        string resourcePath = string `/indexers('${getEncodedUri(indexerName)}')/search.reset`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Runs an indexer on-demand.
    #
    # + indexerName - The name of the indexer to run.
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    remote isolated function indexersRun(string indexerName, IndexersRunHeaders headers = {}, *IndexersRunQueries queries) returns error? {
        string resourcePath = string `/indexers('${getEncodedUri(indexerName)}')/search.run`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Retrieves an indexer definition.
    #
    # + indexerName - The name of the indexer to retrieve.
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    remote isolated function indexersGet(string indexerName, IndexersGetHeaders headers = {}, *IndexersGetQueries queries) returns SearchIndexer|error {
        string resourcePath = string `/indexers('${getEncodedUri(indexerName)}')`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Creates a new indexer or updates an indexer if it already exists.
    #
    # + indexerName - The name of the indexer to create or update.
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The definition of the indexer to create or update. 
    remote isolated function indexersCreateOrUpdate(string indexerName, IndexersCreateOrUpdateHeaders headers, SearchIndexer payload, *IndexersCreateOrUpdateQueries queries) returns SearchIndexer|error {
        string resourcePath = string `/indexers('${getEncodedUri(indexerName)}')`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Deletes an indexer.
    #
    # + indexerName - The name of the indexer to delete.
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    remote isolated function indexersDelete(string indexerName, IndexersDeleteHeaders headers = {}, *IndexersDeleteQueries queries) returns error? {
        string resourcePath = string `/indexers('${getEncodedUri(indexerName)}')`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Lists all indexers available for a search service.
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    remote isolated function indexersList(IndexersListHeaders headers = {}, *IndexersListQueries queries) returns ListIndexersResult|error {
        string resourcePath = string `/indexers`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Creates a new indexer.
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The definition of the indexer to create. 
    remote isolated function indexersCreate(SearchIndexer payload, IndexersCreateHeaders headers = {}, *IndexersCreateQueries queries) returns SearchIndexer|error {
        string resourcePath = string `/indexers`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Returns the current status and execution history of an indexer.
    #
    # + indexerName - The name of the indexer for which to retrieve status.
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    remote isolated function indexersGetStatus(string indexerName, IndexersGetStatusHeaders headers = {}, *IndexersGetStatusQueries queries) returns SearchIndexerStatus|error {
        string resourcePath = string `/indexers('${getEncodedUri(indexerName)}')/search.status`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Retrieves a skillset in a search service.
    #
    # + skillsetName - The name of the skillset to retrieve.
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The skillset is successfully returned. 
    remote isolated function skillsetsGet(string skillsetName, SkillsetsGetHeaders headers = {}, *SkillsetsGetQueries queries) returns SearchIndexerSkillset|error {
        string resourcePath = string `/skillsets('${getEncodedUri(skillsetName)}')`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Creates a new skillset in a search service or updates the skillset if it already exists.
    #
    # + skillsetName - The name of the skillset to create or update.
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The skillset containing one or more skills to create or update in a search service. 
    # + return - The skillset is successfully updated. 
    remote isolated function skillsetsCreateOrUpdate(string skillsetName, SkillsetsCreateOrUpdateHeaders headers, SearchIndexerSkillset payload, *SkillsetsCreateOrUpdateQueries queries) returns SearchIndexerSkillset|error {
        string resourcePath = string `/skillsets('${getEncodedUri(skillsetName)}')`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Deletes a skillset in a search service.
    #
    # + skillsetName - The name of the skillset to delete.
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The skillset is successfully deleted. 
    remote isolated function skillsetsDelete(string skillsetName, SkillsetsDeleteHeaders headers = {}, *SkillsetsDeleteQueries queries) returns error? {
        string resourcePath = string `/skillsets('${getEncodedUri(skillsetName)}')`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List all skillsets in a search service.
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The list is successfully returned. 
    remote isolated function skillsetsList(SkillsetsListHeaders headers = {}, *SkillsetsListQueries queries) returns ListSkillsetsResult|error {
        string resourcePath = string `/skillsets`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Creates a new skillset in a search service.
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The skillset containing one or more skills to create in a search service. 
    # + return - The skillset is successfully created. 
    remote isolated function skillsetsCreate(SearchIndexerSkillset payload, SkillsetsCreateHeaders headers = {}, *SkillsetsCreateQueries queries) returns SearchIndexerSkillset|error {
        string resourcePath = string `/skillsets`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Retrieves a synonym map definition.
    #
    # + synonymMapName - The name of the synonym map to retrieve.
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    remote isolated function synonymMapsGet(string synonymMapName, SynonymMapsGetHeaders headers = {}, *SynonymMapsGetQueries queries) returns SynonymMap|error {
        string resourcePath = string `/synonymmaps('${getEncodedUri(synonymMapName)}')`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Creates a new synonym map or updates a synonym map if it already exists.
    #
    # + synonymMapName - The name of the synonym map to create or update.
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The definition of the synonym map to create or update. 
    remote isolated function synonymMapsCreateOrUpdate(string synonymMapName, SynonymMapsCreateOrUpdateHeaders headers, SynonymMap payload, *SynonymMapsCreateOrUpdateQueries queries) returns SynonymMap|error {
        string resourcePath = string `/synonymmaps('${getEncodedUri(synonymMapName)}')`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Deletes a synonym map.
    #
    # + synonymMapName - The name of the synonym map to delete.
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    remote isolated function synonymMapsDelete(string synonymMapName, SynonymMapsDeleteHeaders headers = {}, *SynonymMapsDeleteQueries queries) returns error? {
        string resourcePath = string `/synonymmaps('${getEncodedUri(synonymMapName)}')`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Lists all synonym maps available for a search service.
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    remote isolated function synonymMapsList(SynonymMapsListHeaders headers = {}, *SynonymMapsListQueries queries) returns ListSynonymMapsResult|error {
        string resourcePath = string `/synonymmaps`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Creates a new synonym map.
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The definition of the synonym map to create. 
    remote isolated function synonymMapsCreate(SynonymMap payload, SynonymMapsCreateHeaders headers = {}, *SynonymMapsCreateQueries queries) returns SynonymMap|error {
        string resourcePath = string `/synonymmaps`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Lists all indexes available for a search service.
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    remote isolated function indexesList(IndexesListHeaders headers = {}, *IndexesListQueries queries) returns ListIndexesResult|error {
        string resourcePath = string `/indexes`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Creates a new search index.
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The definition of the index to create. 
    remote isolated function indexesCreate(SearchIndex payload, IndexesCreateHeaders headers = {}, *IndexesCreateQueries queries) returns SearchIndex|error {
        string resourcePath = string `/indexes`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Retrieves an index definition.
    #
    # + indexName - The name of the index to retrieve.
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    remote isolated function indexesGet(string indexName, IndexesGetHeaders headers = {}, *IndexesGetQueries queries) returns SearchIndex|error {
        string resourcePath = string `/indexes('${getEncodedUri(indexName)}')`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Creates a new search index or updates an index if it already exists.
    #
    # + indexName - The definition of the index to create or update.
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The definition of the index to create or update. 
    remote isolated function indexesCreateOrUpdate(string indexName, IndexesCreateOrUpdateHeaders headers, SearchIndex payload, *IndexesCreateOrUpdateQueries queries) returns SearchIndex|error {
        string resourcePath = string `/indexes('${getEncodedUri(indexName)}')`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Deletes a search index and all the documents it contains. This operation is permanent, with no recovery option. Make sure you have a master copy of your index definition, data ingestion code, and a backup of the primary data source in case you need to re-build the index.
    #
    # + indexName - The name of the index to delete.
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    remote isolated function indexesDelete(string indexName, IndexesDeleteHeaders headers = {}, *IndexesDeleteQueries queries) returns error? {
        string resourcePath = string `/indexes('${getEncodedUri(indexName)}')`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Returns statistics for the given index, including a document count and storage usage.
    #
    # + indexName - The name of the index for which to retrieve statistics.
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    remote isolated function indexesGetStatistics(string indexName, IndexesGetStatisticsHeaders headers = {}, *IndexesGetStatisticsQueries queries) returns GetIndexStatisticsResult|error {
        string resourcePath = string `/indexes('${getEncodedUri(indexName)}')/search.stats`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Shows how an analyzer breaks text into tokens.
    #
    # + indexName - The name of the index for which to test an analyzer.
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The text and analyzer or analysis components to test. 
    remote isolated function indexesAnalyze(string indexName, AnalyzeRequest payload, IndexesAnalyzeHeaders headers = {}, *IndexesAnalyzeQueries queries) returns AnalyzeResult|error {
        string resourcePath = string `/indexes('${getEncodedUri(indexName)}')/search.analyze`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Gets service level statistics for a search service.
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    remote isolated function getServiceStatistics(GetServiceStatisticsHeaders headers = {}, *GetServiceStatisticsQueries queries) returns ServiceStatistics|error {
        string resourcePath = string `/servicestats`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }
}
